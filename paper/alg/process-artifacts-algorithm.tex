\makeatletter
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}%
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%
\makeatletter

\setphaserulewidth{0.4pt}

\begin{breakablealgorithm}
\caption{Trace links graph construction}
\label{alg:process-software-artifacts}
\begin{algorithmic}[1]
\State Input: $RSD$ \Comment{Requirement Specification Document}
\State Input: $GRU$ \Comment{Github Repository URL} 
\State Input: $M$ \Comment{Trace Extraction Method} 
\State Input: $\tau_{e}$ \Comment{Threshold for Vector-Based Methods} 
\State Output: $TG$ : \texttt{graph} \Comment{Trace Graph}
\phase{Fetch Software Artifacts}
% \LineComment{Request from Github graphQL API}
\State $\textit{issueList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} getIssues($GRU$)
\State $\textit{prList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} getPRs($GRU$)
\State $\textit{commitList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} getCommits($GRU$)
% \LineComment{Parse directly from given Requirement Specification Document}
\State $\textit{reqList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} getRequirements($RSD$)

\phase{Create Graph with Artifacts}

\State $\textit{sdaList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} $issueList+prList+commitList$
% \State $\textit{TG} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} $issueNodes+prNodes+commitNodes+reqNodes$\label{algl:m}
\State $TG \leftarrow$  \texttt{graph} 

\For{\textbf{each} $a$ \textbf{in} sdaList}
\State $TG$.addNode(a)
\EndFor

\For{\textbf{each} $r$ \textbf{in} reqList}
\State $TG$.addNode(r)
\EndFor

\phase{Preprocess Artifacts for Trace Extraction}

\State $reqList \leftarrow$ lemmatize($reqList$)
\State $sdaList \leftarrow$ lemmatize($sdaList$)
\If{$method=$ "vector-based"}
\State $reqList \leftarrow$ removeStopwords($reqList$)
\State $sdaList \leftarrow$ removeStopwords($sdaList$)
\EndIf

\phase{Extract Trace Links}
\For{\textbf{each} $r$ \textbf{in} reqList}
\For{\textbf{each} $a$ \textbf{in} sdaList}
% \If{$method=$ "keyword"}
% \State $keywords \leftarrow$ extract(r)
% \If{$a.text$ contains any $kw$ in $keywords$}
% \State $TG$.addEdge(r,a)
% \EndIf
% \EndIf
% \If{$method=$ "vector-based"}
% \State r-v $\leftarrow$ createVector($r.text$)
% \State a-v $\leftarrow$ createVector($a.text$)
% \If{sim(r-v, a-v)  $\geq$ $\tau_{e}$}
% \State $TG$.addEdge(r,a)
% \EndIf
% \EndIf

\Switch{$method$}
\Case{keyword}
    \State $keywords \leftarrow$ extractKeywords(r)
    \If{contains($a.text, keywords$)}
        \State $TG$.addEdge(r,a)
    \EndIf
\EndCase
\Case{tf-idf}
    \State r-v $\leftarrow$ createTfidfVector($r.text$)
    \State a-v $\leftarrow$ createTfidfVector($a.text$)
    \If{sim(r-v, a-v)  $\geq$ $\tau_{e}$}
      \State $TG$.addEdge(r,a)
    \EndIf
\EndCase
\Case{word-vector}
    \State r-v $\leftarrow$ createWordVector($r.text$)
    \State a-v $\leftarrow$ createWordVector($a.text$)
    \If{sim(r-v, a-v)  $\geq$ $\tau_{e}$}
        \State $TG$.addEdge(r,a)
    \EndIf
\EndCase
\EndSwitch
\EndFor
\EndFor

\Return $TG$
\end{algorithmic}

\end{breakablealgorithm}

The \textit{getIssues, getPRs, getCommits} functions take a project repository  ($GRU$) and make API calls to the GitHub API\footnote{\url{https://docs.github.com/en/graphql}} to fetch a list of issues, PRs, and commits respectively. 
It fetches the properties shown in Table \ref{tab:artifactfeatures} for these software software artifacts. 
During preprocessing phase, requirements and software artifacts are lemmatized and english stopwords are removed for vector-based methods. 
Thereafter, the trace links are determined according to desired method.In the keyword based method shared keywords between the requirements and software artifacts are sought. In vector based methods the requirements and artifacts are vectorized and their similarities are compared. When similarities exceed a given threshold edges are formed. For vector-based methods we utilize TF-IDF and word vectors.