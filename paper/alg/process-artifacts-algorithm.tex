\setphaserulewidth{0.4pt}

\begin{breakablealgorithm}
\caption{Trace links graph construction}
\label{alg:process-software-artifacts}
\begin{algorithmic}[1]
\State Input: $RSD$ \Comment{Requirement Specification Document}
\State Input: $GRU$ \Comment{Github Repository URL} 
\State Input: $M$ \Comment{Trace Extraction Method} 
\State Input: $\tau_{e}$ \Comment{Threshold for Vector-Based Methods} 
\State Output: $TG$ : \texttt{graph} \Comment{Trace Graph}
\phase{Fetch Software Artifacts}
% \LineComment{Request from Github graphQL API}
\State $\textit{issueList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} getIssues($GRU$)\label{algl:m}
\State $\textit{prList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} getPRs($GRU$)\label{algl:m}
\State $\textit{commitList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} getCommits($GRU$)\label{algl:m}
% \LineComment{Parse directly from given Requirement Specification Document}
\State $\textit{reqList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} getRequirements($RSD$)\label{algl:m}

\phase{Create Graph with Artifacts}

% \State neo4jConnector($issue_nodes$)\Comment{}

\State $\textit{sdaList} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} $issueList+prList+commitList$\label{algl:m}
% \State $\textit{TG} \hspace{-0.1cm} \leftarrow$  \hspace{-0.2cm} $issueNodes+prNodes+commitNodes+reqNodes$\label{algl:m}
\State $TG \leftarrow$  \texttt{graph} 

\For{\textbf{each} $a$ \textbf{in} sdaList} \label{algl:c}
\State $TG$.addNode(a)
\EndFor \label{algl:c}

\For{\textbf{each} $r$ \textbf{in} reqList} \label{algl:c}
\State $TG$.addNode(r)
\EndFor \label{algl:c}

\phase{Extract Trace Links}

\State preprocess($reqList$, $method$)
\State preprocess($sdaList$, $method$)
\For{\textbf{each} $r$ \textbf{in} reqList}
\For{\textbf{each} $a$ \textbf{in} sdaList}
\If{$method=$ "keyword"}
\State $keywords \leftarrow$ extract(r)
\If{$a.text$ contains any $kw$ in $keywords$}
\State $TG$.addEdge(r,a)
\EndIf
\EndIf
\If{$method=$ "vector-based"}
\State r-v $\leftarrow$ createVector($r.text$)
\State a-v $\leftarrow$ createVector($a.text$)
\If{sim(r-v, a-v)  $\geq$ $\tau_{e}$}
\State $TG$.addEdge(r,a)
\EndIf
\EndIf
\EndFor
\EndFor

\Return $TG$
\end{algorithmic}

\end{breakablealgorithm}

The \textit{getIssues, getPRs, getCommits} functions take a project repository  ($GRU$) and make API calls to the GitHub API\footnote{\url{https://docs.github.com/en/graphql}} to fetch a list of issues, PRs, and commits respectively. 
It fetches the properties shown in Table \ref{tab:artifactfeatures} for these software software artifacts. 
The \textit{$preprocess(list, method)$}  function takes  a list of software artifacts and a method for trace link creation. 
It lemmatizes the text property of each artifact in the list. 
If the method is vector-based then it also removes the stopwords. 
Thereafter, the trace links are determined according to desired method.
In the keyword based method shared keywords between the requirements and software artifacts are sought. In vector based methods the requirements and artifacts are vectorized and their similarities are compared. When similarities exceed a given threshold edges are formed.
In our experiments we utilize TF-IDF and word vectors.


% The $sEdge(req, sda, method)$  function determines whether a trace link exists between a given a requirement ($req$) and a software development artifact ($sda$) based on a trace link $method$. If  $method$ is `keyword extraction', the keywords are extracted from $req$ and $sda$ and an edge is created if they share keywords.
% If  $method$ is `vector-based' (tf-idf or word-embedding) vectors are created for  $req$ and $sda$  using their text property. 
% Then, the similarity between the vectors are calculated. 
% An edge is created if similarity value is above a predefined threshold.
